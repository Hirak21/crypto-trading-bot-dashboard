"""
Base strategy class that all trading strategies inherit from.

This module provides the common functionality and structure that all
trading strategies must implement.
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List
from datetime import datetime, timedelta
import logging

from ..interfaces import IStrategy
from ..models.trading import TradingSignal, MarketData, Trade


class BaseStrategy(IStrategy):
    """Base class for all trading strategies."""
    
    def __init__(self, name: str, parameters: Dict[str, Any] = None):
        self.name = name
        self.parameters = parameters or {}
        self.confidence = 0.0
        self.performance_metrics = {
            'total_trades': 0,
            'winning_trades': 0,
            'losing_trades': 0,
            'total_pnl': 0.0,
            'win_rate': 0.0,
            'avg_win': 0.0,
            'avg_loss': 0.0,
            'sharpe_ratio': 0.0,
            'max_drawdown': 0.0
        }
        self.trade_history: List[Trade] = []
        self.logger = logging.getLogger(f"trading_bot.strategies.{name}")
        
        # Strategy state
        self.is_active = True
        self.last_signal_time = None
        self.cooldown_period = timedelta(minutes=1)  # Minimum time between signals
        
    def get_name(self) -> str:
        """Return the strategy name."""
        return self.name
    
    def get_confidence(self) -> float:
        """Return current strategy confidence level (0.0 - 1.0)."""
        return self.confidence
    
    def get_parameters(self) -> Dict[str, Any]:
        """Return current strategy parameters."""
        return self.parameters.copy()
    
    def set_parameters(self, parameters: Dict[str, Any]) -> bool:
        """Update strategy parameters. Return True if successful."""
        try:
            if self.validate_parameters(parameters):
                self.parameters.update(parameters)
                self.logger.info(f"Parameters updated for {self.name}")
                return True
            else:
                self.logger.error(f"Invalid parameters for {self.name}")
                return False
        except Exception as e:
            self.logger.error(f"Error updating parameters for {self.name}: {e}")
            return False
    
    def analyze(self, market_data: MarketData) -> Optional[TradingSignal]:
        """Analyze market data and generate trading signal if conditions are met."""
        try:
            # Check if strategy is active
            if not self.is_active:
                return None
            
            # Check cooldown period
            if self._is_in_cooldown():
                return None
            
            # Validate market data
            if not self._validate_market_data(market_data):
                return None
            
            # Perform strategy-specific analysis
            signal = self._generate_signal(market_data)
            
            if signal:
                self.last_signal_time = datetime.now()
                self.logger.info(
                    f"Signal generated by {self.name}: {signal.action} "
                    f"for {signal.symbol} with confidence {signal.confidence:.3f}"
                )
            
            return signal
            
        except Exception as e:
            self.logger.error(f"Error in {self.name} analysis: {e}")
            return None
    
    def update_performance(self, trade: Trade) -> None:
        """Update strategy performance metrics based on completed trade."""
        try:
            if trade.strategy != self.name:
                return
            
            self.trade_history.append(trade)
            self.performance_metrics['total_trades'] += 1
            
            if trade.pnl is not None:
                self.performance_metrics['total_pnl'] += trade.pnl
                
                if trade.pnl > 0:
                    self.performance_metrics['winning_trades'] += 1
                    self._update_avg_win(trade.pnl)
                else:
                    self.performance_metrics['losing_trades'] += 1
                    self._update_avg_loss(trade.pnl)
                
                self._update_win_rate()
                self._update_sharpe_ratio()
                self._update_max_drawdown()
                self._update_confidence()
            
            self.logger.info(f"Performance updated for {self.name}")
            
        except Exception as e:
            self.logger.error(f"Error updating performance for {self.name}: {e}")
    
    def get_performance_metrics(self) -> Dict[str, Any]:
        """Get current performance metrics."""
        return self.performance_metrics.copy()
    
    def reset_performance(self) -> None:
        """Reset performance metrics."""
        self.performance_metrics = {
            'total_trades': 0,
            'winning_trades': 0,
            'losing_trades': 0,
            'total_pnl': 0.0,
            'win_rate': 0.0,
            'avg_win': 0.0,
            'avg_loss': 0.0,
            'sharpe_ratio': 0.0,
            'max_drawdown': 0.0
        }
        self.trade_history.clear()
        self.confidence = 0.0
    
    def activate(self) -> None:
        """Activate the strategy."""
        self.is_active = True
        self.logger.info(f"Strategy {self.name} activated")
    
    def deactivate(self) -> None:
        """Deactivate the strategy."""
        self.is_active = False
        self.logger.info(f"Strategy {self.name} deactivated")
    
    @abstractmethod
    def _generate_signal(self, market_data: MarketData) -> Optional[TradingSignal]:
        """Generate trading signal based on strategy logic. Must be implemented by subclasses."""
        pass
    
    @abstractmethod
    def validate_parameters(self, parameters: Dict[str, Any]) -> bool:
        """Validate strategy parameters. Must be implemented by subclasses."""
        pass
    
    def _validate_market_data(self, market_data: MarketData) -> bool:
        """Validate market data quality."""
        if not market_data:
            return False
        
        # Check for required fields
        required_fields = ['symbol', 'timestamp', 'price', 'volume']
        for field in required_fields:
            if not hasattr(market_data, field) or getattr(market_data, field) is None:
                self.logger.warning(f"Missing or invalid field {field} in market data")
                return False
        
        # Check for reasonable values
        if market_data.price <= 0 or market_data.volume < 0:
            self.logger.warning("Invalid price or volume in market data")
            return False
        
        return True
    
    def _is_in_cooldown(self) -> bool:
        """Check if strategy is in cooldown period."""
        if self.last_signal_time is None:
            return False
        
        return datetime.now() - self.last_signal_time < self.cooldown_period
    
    def _update_avg_win(self, pnl: float) -> None:
        """Update average winning trade."""
        winning_trades = self.performance_metrics['winning_trades']
        current_avg = self.performance_metrics['avg_win']
        self.performance_metrics['avg_win'] = (
            (current_avg * (winning_trades - 1) + pnl) / winning_trades
        )
    
    def _update_avg_loss(self, pnl: float) -> None:
        """Update average losing trade."""
        losing_trades = self.performance_metrics['losing_trades']
        current_avg = self.performance_metrics['avg_loss']
        self.performance_metrics['avg_loss'] = (
            (current_avg * (losing_trades - 1) + pnl) / losing_trades
        )
    
    def _update_win_rate(self) -> None:
        """Update win rate."""
        total_trades = self.performance_metrics['total_trades']
        if total_trades > 0:
            self.performance_metrics['win_rate'] = (
                self.performance_metrics['winning_trades'] / total_trades
            )
    
    def _update_sharpe_ratio(self) -> None:
        """Update Sharpe ratio (simplified calculation)."""
        if len(self.trade_history) < 2:
            return
        
        returns = [trade.pnl for trade in self.trade_history if trade.pnl is not None]
        if len(returns) < 2:
            return
        
        avg_return = sum(returns) / len(returns)
        variance = sum((r - avg_return) ** 2 for r in returns) / (len(returns) - 1)
        std_dev = variance ** 0.5
        
        if std_dev > 0:
            self.performance_metrics['sharpe_ratio'] = avg_return / std_dev
    
    def _update_max_drawdown(self) -> None:
        """Update maximum drawdown."""
        if not self.trade_history:
            return
        
        cumulative_pnl = 0
        peak = 0
        max_drawdown = 0
        
        for trade in self.trade_history:
            if trade.pnl is not None:
                cumulative_pnl += trade.pnl
                peak = max(peak, cumulative_pnl)
                drawdown = peak - cumulative_pnl
                max_drawdown = max(max_drawdown, drawdown)
        
        self.performance_metrics['max_drawdown'] = max_drawdown
    
    def _update_confidence(self) -> None:
        """Update strategy confidence based on recent performance."""
        if self.performance_metrics['total_trades'] < 5:
            self.confidence = 0.5  # Neutral confidence for new strategies
            return
        
        # Base confidence on win rate and recent performance
        win_rate = self.performance_metrics['win_rate']
        
        # Look at last 10 trades for recent performance
        recent_trades = self.trade_history[-10:] if len(self.trade_history) >= 10 else self.trade_history
        recent_pnl = sum(trade.pnl for trade in recent_trades if trade.pnl is not None)
        
        # Calculate confidence (0.0 - 1.0)
        base_confidence = win_rate
        recent_performance_factor = 1.0 if recent_pnl >= 0 else 0.8
        
        self.confidence = min(1.0, max(0.1, base_confidence * recent_performance_factor))